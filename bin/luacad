#!/usr/bin/env luajit

local isWindows = package.config:sub(1, 1) == "\\"

-- Get the filename from the command-line argument
local filename = arg[1]
if not filename then
  print("Usage: luacad <file.lua>")
  os.exit(1)
end

-- Add script directory to package.path to ensure libraries are found
local script_path = debug.getinfo(1, "S").source:sub(2):match("(.*/)") or "./"
if not script_path:match("/$") then
  script_path = script_path .. "/"
end
package.path = script_path .. "?.lua;" .. package.path

-- Get absolute path of the input file
local function get_absolute_path(path)
  if path:sub(1, 1) == "/" then
    return path -- Already absolute
  else
    local current_dir = os.getenv("PWD") or io.popen("pwd"):read("*l")
    return current_dir .. "/" .. path
  end
end

filename = get_absolute_path(filename)

-- Save current directory and change to file's directory when executing
local current_dir = os.getenv("PWD") or io.popen("pwd"):read("*l")
local file_dir = filename:match("(.*/)") or "./"

-- Function to execute a file in its directory
local function execute_file(file)
  -- Reset the cad module to clear accumulated variable definitions
  for k, _ in pairs(package.loaded) do
    if k:match("^src%.") then
      package.loaded[k] = nil
    end
  end

  -- Reset cad.scad_variables to clear accumulated variable definitions
  if cad and cad.scad_variables then
    cad.scad_variables = ""
  end

  -- Make sure we're working with a fresh environment
  package.loaded["luacad"] = nil

  local status, err

  -- Fennel file support
  if file:match("%.fnl$") then
    -- Require fennel once (error if missing)
    local fennel_ok, fennel = pcall(require, "fennel")
    if not fennel_ok or not fennel then
      print("Fennel not installed or failed to load. Try `luarocks install fennel`.")
      return false, "fennel missing"
    end

    -- Install the Fennel searcher once so (require :mod) inside Fennel works.
    fennel.install()

    -- Create sandbox env that falls back to the real globals:
    local env = setmetatable({}, { __index = _G })

    -- Execute the file exactly once inside the shared env
    status, err = pcall(function()
      fennel.dofile(file, { env = env })
    end)
  else
    -- For Lua files
    status, err = pcall(dofile, file)
  end

  -- Print errors if any occurred
  if not status then
    print("\nâŒ Error: " .. tostring(err))
  end

  return status, err
end

-- Detect stat variant once at startup: GNU stat uses -c %Y, BSD stat uses -f %m
local stat_fmt
if not isWindows then
  local handle = io.popen("stat --version 2>&1")
  if handle then
    local output = handle:read("*a")
    handle:close()
    if output:match("GNU") then
      stat_fmt = "gnu"
    else
      stat_fmt = "bsd"
    end
  end
end

-- Function to get the file modification time using system commands
local function get_mtime(file)
  local cmd
  if isWindows then
    cmd = 'for %A in ("' .. file .. '") do @echo %~tA'
  elseif stat_fmt == "gnu" then
    cmd = 'stat -c %Y "' .. file .. '"'
  else
    cmd = 'stat -f %m "' .. file .. '"'
  end

  local handle = io.popen(cmd)
  if not handle then
    print("Error: Failed to execute command: " .. cmd)
    return 0
  end
  local result = handle:read("*a")
  handle:close()
  return tonumber(result) or 0
end

-- Reset modules on startup to ensure clean environment
for k, _ in pairs(package.loaded) do
  if k:match("^src%.") then
    package.loaded[k] = nil
  end
end

-- If cad module exists, reset scad_variables
if cad and cad.scad_variables then
  cad.scad_variables = ""
end

-- Initial execution
print("Executing: " .. filename)
execute_file(filename)

-- Watch loop
local last_mtime = get_mtime(filename)

print("\nWatching for changes... (press ctrl+c to exit)")
local ok, err = pcall(function()
  while true do
    local current_mtime = get_mtime(filename)
    if current_mtime ~= last_mtime then
      last_mtime = current_mtime
      print('\nðŸ”„ Re-executing "' .. filename .. '"')
      local success, error_msg = execute_file(filename)
      if not success then
        print("Fix the error and save to try again.")
      end
    end
    -- Sleep to reduce CPU usage
    if isWindows then
      os.execute("timeout /t 1 >nul")
    else
      -- Sleep with timeout in a way that can be interrupted
      local exit_code = os.execute("sleep 0.1")
      if exit_code ~= 0 and exit_code ~= true then
        print("\nExiting...")
        break
      end
    end
  end
end)

if not ok then
  print("\nExiting... " .. (err or ""))
end
